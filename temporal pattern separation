//include headers
#include <reg51.h>

//pins are configured here
sbit TONE = P1^0; 								//output pins
sbit leftvalve = P1^2;
sbit rightvalve = P1^1;
P1_1 = 1;													//input pins
P1_2 = 1;	

//global variables 
int TH0BIT; 											//TxOBITs used to set frequency of square wave. Calculation for 10,000HZ wave  
int TL0BIT;												//(.0001s period) 65535-(24000000/12/10000)=65335(dec)->FF37(hex) TH0=FF TL0=37
																	//lickwindow, etc. and resets to zero each time the program switches between these phases
int continouscounter = 0;					//counts number of times that timer 1 resets without resetting to know the overall time 
																	//passes in the duration of the program
int timer1flag;                   //set to 1 everytime timer1 overflows

//functions and interrupts
void transmit(unsigned char x){		//function used to transmit serial data
	SBUF = x; 													//transmit bit to com port
	while(TI==0) {}											//wait for byte to be transmitted
	TI = 0;}														//clear transmit interrupt flag

void receive(){  									//function receives serial data
	unsigned char value;								//initialize a variable that will equal whatever's sent through serial
	while(RI==0);												//wait for entire byte to be received
	value=SBUF;													//set aforementioned variable to serial data
	P2=value;														//Second register equals value
	RI=0;}															//reset receive interrupt

void timer0(void) interrupt 1	{		//timer 0 interrupt used for generating square wave for tones
  TH0=TH0BIT;                         // timer reloaded 
 	TL0=TL0BIT;   
	TONE=~TONE;}                        //toggle or untoggle TONE on interrupt

void timer1(void) interrupt 3 {   /* timer 1 interrupt used to count how much time passes so that it knows when to: 
                                     play or stop playing tones, start lickwindow, stop lickwindow, start delay, etc. */
	TL1=0x0B;                           // initial values loaded to timer 50HZ (.02s period) 
	TH1=0x63;                           // 65355-(24,000,000/12/50)=25355 25355(dec)->630B(hex) TH1=63 TL1=0B
	timer1flag = 1;
	continouscounter++;
}	

int rand(void);  									//random number generator
void srand(unsigned int seed);    //sets a seed to rng

main(){ 
	//choose modes
	const int delay_onoff = 0;	               	 //set to 1 to delay mouse if it doesn't lick correctly or at all; set 0 otherwise
  const int blocks = 0;                        //set to 1 if you want to use the block training protocol; set to 0 otherwise
  const int training = 0;											 //set to 1 if you want the appropriate reward valve to open every time a sequence is played
	//configurable parameters
	const int duration_delay = (5)/.02;                   //set time you want the delay to be in seconds in the parenthesises
	const int duration_tones = (.2)/.02;		              //set duration of tones in seconds in the parenthesises
  const int duration_time_between_tones = (.3)/.02;     //set duration of time between tones in the parenthesises
	const int duration_lickwindow = (2)/.02;					    //set duration of lickwindow in seconds in the parenthesises
	const int duration_open_valve = (.1)/.02;	            //set duration of open reward valve in seconds in the parenthesises
	const int trial_number = 200;											    //sets number of trials
	
	//other variables    
	char xdata sequence[200][2][4];	            //sequence[trial_number][x][k] x=0 contains nontarget sequence; 
																	  	        //x=1 contains the sequence that is played
	const int duration_sequence = 4*duration_tones + 3*duration_time_between_tones;
	const int duration_tones_and_space = duration_tones + duration_time_between_tones;
	int timer1counter;
	int j; 														//j is the index used to indicate which sequence is being played
	int tones = 1;										//tones = 1 means indicates that the tones are playing; tones = 0 means otherwise
	int lickwindow = 0;								//lickwindow = 1 indicates that the lickwindow is on; lickwindow = 0 means otherwise
	int delay = 0;										//delay = 1 indictates that it is the delay time between lickwindow and next song
  int k;												            //k is the index used to indicate which tone is playing of the trial_numberth sequence
	int lick;															  	//lick=1 indicates that the mouse licked left; lick=0 --> right
	int leftlick = 0;												  //if leftlick = 1, mouse made contact with left lick port
	int rightlick = 0;												//if leftlick = 1, mouse made contact with right lick port
	int leftlastlick = 0;											//keeps track if left side was licked in the last data sampling
	int rightlastlick = 0;								    //keeps track if right side was licked in the last data sampling
	int leftlickcounter = 0;									//counts the number of consecutive times in which the left lick ports reads HIGH
	int rightlickcounter = 0;									//counts the number of consecutive times in which the right lick ports reads HIGH
	int correct;															//correct=1 indicates mouse licked correctly; correct = 0 incorrect lick; correct = 2 indicates no lick
  int target = 0;								            //if target = 0, target sequence plays. if target = 1, nontarget sequence plays
	int lasttarget = target;
  char toneslist[8] = {'a','b','c','d','e','f','g','\0'};		//array used to randomly generate sequences
	for (j = 0 ; j <= trial_number ; j++){							
		for (k = 0 ; k <= 3 ; k++){					    		//this loop generates nontarget sequence in the second column of sequence
			int randindex = rand() % 6;
			sequence[trial_number][0][k] = toneslist[randindex];
	  }
	}
	srand(7);																			//seed rng
	SCON=0x10;                                    //enable serial receive --- 8-bit Shift Register Mode: (baud rate = crystal/12)
	IE = 0x8A;    																//enable global interrupt and timer0 and timer1 and serial interrupts 
	TMOD = 0x11; 	                               	//16 bit timers for timer 1 and timer 0
	TL1=0x0B;                                     //initial values loaded to timer 50HZ (.02s period) 
	TH1=0x63;                                     //65355-(24,000,000/12/50)=25355 25355(dec)->630B(hex) TH1=63 TL1=0B
	TR1 = 1;						                          //start timer 1
	for(j = 0 ; j < trial_number ; j++){
		if (target == 0){
			sequence[j][0][0] = 'c';                  //if it's supposed to play target sequence
			sequence[j][0][1] = 'd';                  //it overwrites the nontarget sequence that was
			sequence[j][0][2] = 'e';									//that was there before
			sequence[j][0][3] = 'f';
		}
		k = 0;
		TR0 = 1;
		while(tones == 1){
			leftlick = P1_2;													//read the input lick pins
			rightlick = P1_1;
//      transmit('time,leftlick,rightlick');	  	//send that info to serial
			if (timer1flag == 1){                     //if timer1flag goes HIGH, increase timer1counter and check if the tone should
				timer1counter++;											  //start/stop playing, change, or move onto lickwindow
			  if (timer1counter == (k+1)*duration_tones || timer1counter == (k+1)*duration_tones_and_space){
			    TR0=~TR0; 												//toggle timer 0 which toggles tone
					if (timer1counter % duration_tones_and_space == 0){
						k++;
						if (sequence[trial_number][1][k] == 'a'){
							TH0BIT = 0xFE;
							TL0BIT = 0xE3;
						}
						else if (sequence[trial_number][1][k] == 'b'){
							TH0BIT = 0xFF;
							TL0BIT = 0x02;
						}
						else if (sequence[trial_number][1][k] == 'c'){
							TH0BIT = 0xFF;
							TL0BIT = 0x10;
						}
						else if (sequence[trial_number][1][k] == 'd'){
							TH0BIT = 0xFF;
							TL0BIT = 0x2A;
						}
						else if (sequence[trial_number][1][k] == 'e'){
							TH0BIT = 0xFF;
							TL0BIT = 0x41;
						}
						else if (sequence[trial_number][1][k] == 'f'){
							TH0BIT = 0xFF;
							TL0BIT = 0x4C;
						}
						else if (sequence[trial_number][1][k] == 'g'){
							TH0BIT = 0xFF;
							TL0BIT = 0x60;
						}
					}
			  }
        else if (timer1counter == duration_sequence){
					tones = 0;
					lickwindow = 1;
					timer1counter = 0;
					TR0 = 0;
				}	
		  }
		}
		while (training == 1 && lickwindow == 1){
			leftlick = P1_2;
			rightlick = P1_1;
//      transmit('time,leftlick,rightlick');
		}
		while(training == 0 && lickwindow == 1){
      leftlick = P1_2;
			rightlick = P1_1;
//      transmit('time,leftlick,rightlick');
			if (timer1flag == 1){
				timer1counter++;
				timer1flag = 0;
				if (timer1counter == duration_lickwindow){
					lickwindow = 0;
					delay = 1;
				}
			}
			if (leftlick == 1){
				leftlickcounter = leftlickcounter++;			  
				if (leftlickcounter >= 10){
					leftlickcounter = 0;
					lick = 1;
					timer1counter = 0;
					lickwindow = 0;
					if (target == 1){
						lasttarget = target;
						delay = 0;
						correct = 1;
  				  target = rand()%2;
					}
					else{
						delay = 1;
						correct = 0;
					}
					timer1counter = 0;
				}
			}
			else{
				leftlickcounter = 0;
			}
			if (rightlick == 1){
				rightlickcounter = rightlickcounter++;
				if (rightlickcounter >= 10){
					rightlickcounter = 0;
					lick = 2;
					lickwindow = 0;
					if (target == 0){
						lasttarget = target;
						delay = 0;
						correct = 1;
						target = rand()%2;
					}
					else{
						delay = 1;
						correct = 0;
					}
		      timer1counter = 0;
				}
			}
			else{
				rightlickcounter = 0;
			}
		}
		if (correct == 1 || training == 1){
			if (lasttarget == 0){
				rightvalve = 1;
			}
			else{
				leftvalve = 1;
			}
	  }
		while (correct == 1 || training == 1){
			leftlick = P1_2;
			rightlick = P1_1;
//      transmit('time,leftlick,rightlick');
			if (timer1flag == 1){
				timer1counter++;
				if (timer1counter == duration_open_valve){
					timer1counter = 0;
					rightvalve = 0;
					leftvalve = 0;
			  }
		  }
		}
		if (delay_onoff == 1){
			while (delay == 1){
				if (timer1flag == 1){
					timer1counter++;
					if (timer1counter == duration_delay){
						delay = 0;
						tones = 1;
						timer1counter = 0;
					}
				}
				leftlick = P1_2;
				rightlick = P1_1;
	//    transmit('time,leftlick,rightlick');
				
			}
		}
		else{
			delay = 0;
			tones = 1;
			timer1counter = 0;
		}
	}
//  transmit('j,lick,sequence[trial_number][1]')
}
